#!/usr/bin/env bash
[[ ! -v _COMMON_BASHLIB ]] || return 0; _COMMON_BASHLIB=

# init
#	Initiate basic settings / traps (optional)
init() {
	set +m -Efuo pipefail
	shopt -s lastpipe nullglob

	trap '
		case ${?} in
			166) (( BASH_SUBSHELL )) && exit 166 || exit 0;;
			167) (( BASH_SUBSHELL )) && exit 167 || exit 1;;
		esac' ERR

	: "@eprefix@"
	: "${ROOT=}"; ROOT=${ROOT%/}
	: "${EROOT=${ROOT}${EPREFIX:-}}"; EROOT=${EROOT%/}
	export ROOT EROOT EPREFIX

	_COMMON_INIT=
}

# depend <executables...>
#	Check for executables in PATH to die early if any missing.
depend() {
	type -f "${@}" >/dev/null || die "missing dependencies"
}

# die [message]
#	Exit with error (usable in non-masked subshells with init())
#	If no message, display generic error with failed line and backtrace.
die() {
	echo "Error: ${*:-unexpected issue happened at the following} (${0##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]})" >&2

	if (( ! ${#} )); then
		local i
		showline ${BASH_LINENO[0]} "${BASH_SOURCE[1]}" '  %03d: %s' >&2
		for ((i=1; i < ${#FUNCNAME[@]}; i++)); do
			printf "%-$((i*4-2))s^^^ %s\n" '' "${FUNCNAME[i]}:${BASH_LINENO[$((i-1))]}" >&2
		done
	fi

	end 1
}

# end [01]
#	Exit with [01] (default:0, usable in non-masked subshells with init())
end() {
	[[ -v _COMMON_INIT ]] || exit "${1:-0}"
	(( BASH_SUBSHELL )) && exit "$((166+${1:-0}))" || exit "${1:-0}"
}

# err <message>
#	Print error message to stderr
err() {
	echo "Error: ${*} (${0##*/})" >&2
}

# getoptw [<variable> <array> <short> <long> <args...>] (depend:getopt)
#	Wrapper to external getopt(1), only initial call takes arguments.
#	<short> and <long> are getopt(1)'s -o and -l options.
#	If no arguments, set named <variable> to next option with each call.
#	If reach --, set named <array> to remaining options.
#	Return 1 when no options left.
#	Dies if invalid options passed.
getoptw() {
	if (( ${#} )); then
		eval "
			_COMMON_SETOPT=($(getopt -o "${3}" -l "${4}" -- "${@:5}"))
			(( ! ${?} )) || die 'invalid arguments'
			${2}=()"
		_COMMON_SETOPT_V=${1}
		_COMMON_SETOPT_A=${2}
		declare -gi _COMMON_SETOPT_P=0
		return 0
	fi

	[[ -v _COMMON_SETOPT ]] || return 1

	if (( _COMMON_SETOPT_P >= ${#_COMMON_SETOPT[@]} )); then
		eval "unset _COMMON_SETOPT{,_V,_A} ${_COMMON_SETOPT_V}"
		return 1
	fi

	if [[ ${_COMMON_SETOPT[_COMMON_SETOPT_P]} == -- ]]; then
		(( ++_COMMON_SETOPT_P >= ${#_COMMON_SETOPT[@]} )) \
			|| eval "${_COMMON_SETOPT_A}"'=("${_COMMON_SETOPT[@]:${_COMMON_SETOPT_P}}")'
		eval "unset _COMMON_SETOPT{,_V,_A} ${_COMMON_SETOPT_V}"
		return 1
	fi

	eval "${_COMMON_SETOPT_V}"'=${_COMMON_SETOPT[((_COMMON_SETOPT_P++))]}'
}

# include <files...>
#	Include files from current bashlib dir, exit on failure
include() {
	while (( ${#} )); do
		. "${BASH_SOURCE[0]%/*}/${1}.bashlib" || exit 1
		shift
	done
}

# map [+]<array>
#	Wrapper to mapfile using -t by default and opting to add to array
#	rather than reset if + is prepended.
map() {
	if [[ ${1:0:1} == + ]]; then
		eval 'mapfile -t -O "${#'"${1#+}"'[@]}" "${1#+}"'
	else
		mapfile -t "${1}"
	fi
}

# msg <message>
#	Echoes message based on setmsg() defaults.
msg() {
	printf "${_COMMON_MSG_FMT:-%s\n}" "${@}" >&"${_COMMON_MSG_STD:-1}"
}

# optstart
#	Setup O and C associative arrays (option/colors), and CONFDIRS array.
#	Usage:
#		optstart <<-EOO
#			name=type:default (type = bool, float(int*100), int, str)
#			short|!name=type:default (short| and ! optional for optauto())
#			...
#		EOO
#		optset <key> <val> (override default with arguments, used over configs)
#		optsetconf <dir> (override default CONFDIRS by <dir> if needed)
#		optend (load configs and normalize arrays for usage)
#	Alternatively, optauto <<-EOO... does all of the above combined.
#	After optend(), e.g. ${O[boolname]} = true, ${C[g]} = green ansi color
#	Note: include c|!color=bool:true to enable C array / colormap
optstart() {
	_COMMON_OPT_SORT=()
	declare -gA O C _COMMON_OPT{,_NO,_SHORT{,_R}}

	local l key opt
	while IFS= read -r l; do
		opt=${l%%=*}
		key=${opt#*|}
		key=${key#!}

		if [[ ${opt} =~ '!' ]]; then
			_COMMON_OPT_NO[${key}]=
		fi

		if [[ ${opt} =~ '|' ]]; then
			key=${key#*|}
			_COMMON_OPT_SHORT[${key}]=${l:0:1}
			_COMMON_OPT_SHORT_R[${l:0:1}]=${key}
		fi

		_COMMON_OPT_SORT+=("${key}")
		_COMMON_OPT[${key}]=${l#*=}
	done
	_COMMON_OPT_SORT+=(colormap)
	_COMMON_OPT[colormap]="colormap:r31 g32 y33 b34 m35 c36 a90 la37 lr91 lg92 ly93 lb94 lm95 lc96 w97 n0"

	set -- \
		"@confdir@" \
		"${0%/*}/../config" \
		"${XDG_CONFIG_HOME:-${HOME}/.config}/@package@"
	declare -ga CONFDIRS=()
	while (( ${#} )); do
		[[ ! -d ${1} ]] || CONFDIRS+=("${1}")
		shift
	done
}

# optset <key> <value> [-c]
#	Set O[<key>] to <value> after sanity checks, die on error, see optstart().
#	-c indicates set from a config file and will not override non-default/-c
optset() {
	local isset='%' type=${_COMMON_OPT[${1}]%:*} val

	if [[ ${3:-} == -c ]]; then
		[[ ${type} != %* ]] || return 0
		isset='@'
	fi
	type=${type#[%@]}

	case ${type} in
		bool)
			case ${2,,} in
				1|enable|true|yes|y) val=true;;
				0|disable|false|no|n) val=false;;
			esac
		;;
		colormap)
			printf -v val 'r%d g%d y%d b%d m%d c%d a%d la%d lr%d lg%d ly%d lb%d lm%d lc%d w%d n%d' \
				${2} 2>/dev/null || unset val
		;;
		float)
			printf -v val '%.2f' "${2%\%}" 2>/dev/null \
				&& printf -v val '%.0f' "${val}e+2" 2>/dev/null \
				|| unset val
		;;
		int)
			printf -v val '%d' "${2}" 2>/dev/null || unset val
		;;
		str) val=${2};;
		*) die;;
	esac

	[[ -v val ]] || die "unrecognized value '${2}' for option '${1}', expected ${type}"

	_COMMON_OPT[${1}]=${isset}${type}:${val}
}

# optsetconf <dir>
#	Override CONFDIRS to use <dir> or die if not a directory, see optstart().
optsetconf() {
	[[ -d ${1} ]] || die "configuration directory '${1}' is not a directory"
	CONFDIRS=("${1}")
}

# optend [-d]
#	See optstart()
#	If -d is specified, dump configuration and exit (usable as .conf)
optend() {
	local file l key val

	for file in "${CONFDIRS[@]/%//${0##*/}.conf}"; do
		[[ -e ${file} ]] || continue
		while IFS= read -r l; do
			[[ ! ${l} =~ ^# ]] || continue
			[[ ${l} =~ ^[[:space:]]*([a-z-]+)[[:space:]]*=[[:space:]]*([^#]*) ]] \
				|| die "could not parse line from '${file}': ${l}"

			key=${BASH_REMATCH[1]}
			val=${BASH_REMATCH[2]%"${BASH_REMATCH[2]##*[![:space:]]}"}
			val=${val//[\"\'\\]/} #"]}#vim

			[[ ${_COMMON_OPT[${key}]:-} =~ : ]] || die "invalid option in '${file}': ${key}"

			optset "${key}" "${val}" -c
		done < "${file}" || die "failed to read '${file}'"
	done

	if [[ ${1:-} == -d ]]; then
		echo "# ${0##*/}.conf"
		for key in "${_COMMON_OPT_SORT[@]}"; do
			[[ ${_COMMON_OPT[${key}]} =~ ^[%@] ]] && l= || l='#'
			if [[ ${key} == colormap ]]; then
				[[ ! ${_COMMON_OPT[color]:-} ]] \
					|| echo "${l}${key} = ${_COMMON_OPT[colormap]//[a-z:]/}"
			elif [[ ${_COMMON_OPT[${key}]} =~ (^\ |\ $) ]]; then
				# quotes only needed if spaces are at end/start
				echo "${l}${key} = \"${_COMMON_OPT[${key}]#*:}\""
			else
				echo "${l}${key} = ${_COMMON_OPT[${key}]#*:}"
			fi
		done
		exit
	fi

	for key in "${!_COMMON_OPT[@]}"; do
		[[ ${key} != colormap ]] || continue
		O[${key}]=${_COMMON_OPT[${key}]#*:}
	done

	for val in ${_COMMON_OPT[colormap]#*:}; do
		if [[ ${O[color]:-} == true ]]; then
			printf -v "C[${val%%[0-9]*}]" "\e[${val##*[a-z]}m"
		else
			C[${val%%[0-9]*}]=
		fi
	done

	unset _COMMON_OPT{,_NO,_SHORT{,_R}}
}

# optauto <array> <args...> << (depend:getopt)
#	Combines opt* and getoptw(), see optstart().
#	Named [array] will store remaining arguments, see getoptw().
#	On top of defined options, will add:
#		-h|--help, --version, --confdir=PATH, --dumpconfig
#	Options prefixed by ! (i.e. s|!long=) will add --no-*
optauto() {
	optstart

	local key short=h long=help,version,confdir:,dumpconfig
	for key in "${_COMMON_OPT_SORT[@]}"; do
		# note: undocumented but no reason to skip --colormap if enabled
		[[ ${key} != colormap || ${_COMMON_OPT[color]:-} ]] || continue
		[[ ${_COMMON_OPT[${key}]} =~ ^bool: ]] && hasarg= || hasarg=:
		[[ -v _COMMON_OPT_NO[${key}] ]] && long+=,no-${key} || long+=,${key}${hasarg}
		short+=${_COMMON_OPT_SHORT[${key}]:+${_COMMON_OPT_SHORT[${key}]}${hasarg}}
	done

	local arg prev
	getoptw arg "${1}" "${short}" "${long}" "${@:2}"
	while getoptw; do
		case "${arg}" in
			-h|--help) usage;;
			--version) version;;
			--confdir) getoptw; optsetconf "${arg}";;
			--dumpconfig) optend -d;;
			-?) arg=${_COMMON_OPT_SHORT_R[${arg#-}]};&
			*)
				arg=${arg#--}
				arg=${arg#no-}
				if [[ ${_COMMON_OPT[${arg}]} =~ ^bool:(true|'') ]]; then
					if [[ ${BASH_REMATCH[1]} ]]; then
						optset "${arg}" false
					else
						optset "${arg}" true
					fi
				else
					prev=${arg}; getoptw
					optset "${prev}" "${arg}"
				fi
			;;
		esac
	done

	optend
}

# setmsg [12] [format]
#	Set how to output messages from msg()
#	Default if not used: 1(stdout) '%s\n'
setmsg() {
	if [[ ${1} == [12] ]]; then
		_COMMON_MSG_STD=${1}
		shift
	fi
	(( ! ${#} )) || _COMMON_MSG_FMT=${1}
}

# showline <lineno> <source> [format]
#	Echoes line(s) at, may be multiple lines if terminated by \
#	Format can contain one %d for line number, then %s for the line.
#	Return 1 if failed to read source file
showline() {
	local d= format=${3:-%03d: %s}
	local -a source output

	[[ ${format} =~ %+[0-9.-]*d ]] || unset d

	mapfile -tn "${1}" source < "${2}" || return 1

	output=(${d+${1}} "${source[$((${1} - 1))]//$'\t'/    }")

	local -i i
	for ((i=${1} - 1; --i >= 0;)); do
		[[ ${source[i]} =~ \\$ ]] || break
		output=(${d+$((i+1))} "${source[i]//$'\t'/    }" "${output[@]}")
	done

	printf "${format}\n" "${output[@]}"
}

# usage [<<]
#	Read stdin for usage, then subsequent call will display it and exit.
usage() {
	if [[ ! -v _COMMON_USAGE ]]; then
		mapfile _COMMON_USAGE
		return 0
	fi
	printf %s "${_COMMON_USAGE[@]}"
	exit
}

# version
#	Show version and exit
version() {
	echo "${0##*/} @version@"
	exit
}

# vim: ts=4
