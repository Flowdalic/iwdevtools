#!/usr/bin/env bash
version() { echo "${0##*/} @version@"; exit; }
usage() {
	cat <<-EOF
		Usage: ${0##*/} [options] <atom>

		Perform basic QA checks based on vdb's contents (/var/db/pkg). Currently
		supports comparing RDEPEND with DT_NEEDED (i.e. from \`scanelf -n\`), and
		doing simple verification of binding operators / slots.

		<atom> can be the exact vdb entry, or anything portage accepts
		  e.g. sys-devel/gcc:10, portage-utils, ~sys-apps/portage-3.0.20

		Options:
		  -s, --no-slot            Exclude slots (e.g. needing :3 on gtk+, or :*)
		  -b, --no-bind            Exclude binding operators (implies --no-overbind)
		  -o, --no-overbind        Exclude superfluous binds (i.e. for subslot 0)
		  -x, --no-extra           Exclude listed dependencies that seem unused
		  (using all --no-* or -sbx will limit to entirely missing deps)

		  -e, --exclude=LIST       Comma separated list of category/package to
		                           exclude, can also be specified multiple times
		                           (example: dev-python/*,sys-libs/glibc,*/gcc)
		      --exclude-slot=LIST  Like --exclude but to selectively --no-slot
		      --exclude-bind=LIST  Like --exclude but to selectively --no-bind
		      --exclude-extra=LIST Like --exclude but to selectively --no-extra
		      --exclude-lib=LIST   Similar to --exclude but takes .so libraries
		                           as arguments and excludes if seen in DT_NEEDED
		  (packages that provide no shared libraries are always excluded)

		  -D, --depend             Check against DEPEND rather than RDEPEND
		                           (virtuals will still use RDEPEND)

		  -W, --confirm            Show confirmation if no issues rather than silence

		  -u, --ignore-uninstalled Allows to keep going if a dependency that should
		                           be in vdb, isn't. In theory this should never
		                           happen without package.provided or bugs.

		  -U, --unified            Use \`diff -U\` for output instead builtin
		  -F, --full               When showing differences, display unchanged as well

		  -c, --no-color           Disable use of colors

		  -r, --no-default-exclude Ignore configuration files for excludes
		      --confdir=PATH       Configuration dir to use instead of defaults
		                           (@confdir@ + ${XDG_CONFIG_HOME:-~/.config}/@package@)
		                           Note: portage will use a different \$HOME

		  -h, --help               Display usage information and exit
		      --version            Display version information and exit

		Can be integrated with portage through /etc/portage/bashrc, see
		provided qa-vdb.bashrc for details and options.

		Output is not a hard indication that something needs fixing (especially
		with seemingly unused deps) and needs a human to interpret it.
	EOF
	exit
}

set -uo pipefail
MAINPID=${$}
die() { echo "Error: ${*} (${FUNCNAME[1]})" >&2; kill -USR1 ${MAINPID}; exit 1; }
msg() { local IFS=$'\n'; set -- "${*}"; printf "%s\n" "${@}"; }
trap 'exit 1' USR1

# Dependencies:
#	app-portage/portage-utils (qatom,qfile,qlist)
#	sys-apps/coreutils (cat,sort,tr,uniq)
#	sys-apps/diffutils (diff)
#	sys-apps/portage (portageq)
#	sys-apps/sed (sed)
#	sys-apps/util-linux (getopt)
#	sys-libs/glibc (ldconfig) [optional]
type cat diff getopt portageq qatom qfile qlist sed sort tr uniq >/dev/null || die "missing dependencies"

declare -A OPT
OPT[slot]=true
OPT[bind]=true
OPT[overbind]=true
OPT[extra]=true
OPT[exclude]=
OPT[exclude-slot]=
OPT[exclude-bind]=
OPT[exclude-extra]=
OPT[exclude-lib]=
OPT[ignore]=
OPT[depend]=RDEPEND
OPT[confirm]=false
OPT[ignore-uninstalled]=false
OPT[unified]=false
OPT[full]=false
OPT[color]=true
OPT[default-exclude]=true
OPT[confdir]=
OPT[sysconfdir]="@confdir@"
OPT[userconfdir]="${XDG_CONFIG_HOME:-${HOME}/.config}/@package@"

eval set -- $(getopt \
	-o hsboxe:DWuUFcr \
	-l help,version,no-slot,no-bind,no-overbind,no-extra,exclude:,exclude-slot:,exclude-bind:,exclude-extra:,exclude-lib:,depend,confirm,ignore-uninstalled,unified,full,no-color,no-default-exclude,confdir: \
	-- "${@}" || die "invalid arguments")
while (( ${#} )); do
	case ${1} in
		-h|--help) usage;;
		   --version) version;;
		-s|--no-slot) OPT[slot]=false;;
		-b|--no-bind) OPT[bind]=false;;
		-o|--no-overbind) OPT[overbind]=false;;
		-x|--no-extra) OPT[extra]=false;;
		-e|--exclude) OPT[exclude]+=,${2}; shift;;
		   --exclude-slot) OPT[exclude-slot]+=,${2}; shift;;
		   --exclude-bind) OPT[exclude-bind]+=,${2}; shift;;
		   --exclude-extra) OPT[exclude-extra]+=,${2}; shift;;
		   --exclude-lib) OPT[exclude-lib]+=,${2}; shift;;
		-D|--depend) OPT[depend]=DEPEND;;
		-W|--confirm) OPT[confirm]=true;;
		-U|--unified) OPT[unified]=true;;
		-F|--full) OPT[full]=true;;
		-u|--ignore-uninstalled) OPT[ignore-uninstalled]=true;;
		-c|--no-colors) OPT[color]=false;;
		-r|--no-default-exclude) OPT[default-exclude]=false;;
		   --confdir) OPT[confdir]=${2}; shift;;
		--) shift; break;;
	esac
	shift
done
(( ${#} == 1 )) || die "no atom specified, see \`${0##*/} --help\`"

: @eprefix@
: ${ROOT=''}; ROOT=${ROOT%/}
: ${EROOT=${ROOT}${EPREFIX:-}}; EROOT=${EROOT%/}
export ROOT EROOT EPREFIX

# vdb-get_atomf <format> <atom>
#	Echos <atom> based on <format> using qatom -F.
vdb-get_atomf() {
	qatom -CqF "${@}" || die "q command failed: qatom -CqF ${*}"
}

# vdb-get_pf2pn <CATEGORY/PF>
#	Echos CATEGORY/PN after removing version from PF, wrapper to vdb-get_atomf
vdb-get_pf2pn() {
	vdb-get_atomf '%{CATEGORY}/%{PN}' "${1}"
}

# vdb-get_dep2entry <dependency>
#	Echos the conversion of a full ">=category/package-ver:slot/sub[use]"
#	to a matching vdb entry. May not always be a perfect match.
vdb-get_dep2entry() {
	local dep

	# qlist understands slots/ranges, but can't handle subslots, :*, and [use]
	# not using qatom due to how it strips wildcards from versions
	dep=${1%\[*}
	dep=${dep%=}
	dep=${dep%:\**}
	[[ ${dep} == */*/* ]] && dep=${dep%/*}

	# don't check for failure as it's normal if dep is not installed,
	# fickle but this is relevant when checking for || ( ) deps
	qlist -CqveI "${dep}" | tail -n 1
}

# vdb-get_entry <atom>
# 	Echos ${CATEGORY}/${PF} (matching vdb entry) for <atom>.
#	e.g. sys-devel/gcc:10 -> sys-devel/gcc-10.3.0-r2
vdb-get_entry() {
	# check for exact match first
	if [[ -r ${VDB}/${1#=}/EAPI ]]; then
		echo ${1#=}
		return
	fi

	# perform a search
	local match
	match=$(portageq match "${EROOT:-/}" "${1}") \
		|| die "portageq match failed for '${match}'"

	if [[ ${match} == *$'\n'* ]]; then
		msg "Multiple vdb entries for '${1}':"
		msg "${match}"
		die "specific match required"
	fi

	[[ -r ${VDB}/${match}/EAPI ]] || die "'${1}' was not found in vdb"

	echo ${match}
}

# vdb-get_expected_slot <CATEGORY/PN(dep)> <SLOT> <SUBSLOT> <CATEGORY/PN(pkg)> [prebuilt]
#	Echos :SLOT= string that'd be expected in dependencies.
#	- if slot is non-zero, should have a :N
#	- if subslot is non-zero, should (usually) have :=
#	 (dev-qt/* notable exception to the above)
#	- if both are 0, this returns nothing
#   - prebuilt cause a special exclusion for binding operators
#     TODO: maybe it should show exact subslots?
vdb-get_expected_slot() {
	local slot=${2} subslot=${3}

	if ! ${OPT[slot]} || vdb-is_excluded exclude-slot ${1} ${4}; then
		 slot=0
	fi
	if ! ${OPT[bind]} || vdb-is_excluded exclude-bind ${1} ${4} || [[ ${5:-} == prebuilt ]]; then
		subslot=0
	fi

	if [[ ${subslot} != 0 ]]; then
		echo :${slot#0}=
	elif [[ ${slot} != 0 ]]; then
		echo :${slot}
	fi
}

# vdb-get_libdeps <CATEGORY/PF>
#	Echos package list providing shared libraries based
#	on <CATEGORY/PF>'s vdb RDEPEND.
#	Output should be identical to vdb-get_libneed if no missing deps.
vdb-get_libdeps() {
	# get vdb-get_libneed for multiple comparison (for *-extra)
	local need=$(vdb-get_libneed ${1})

	local prebuilt=
	vdb-is_prebuilt ${1} && prebuilt=prebuilt

	local pkg=$(vdb-get_pf2pn ${1})

	local IFS=$'\n' provides rdep vrdep
	for rdep in $(vdb-get_deps ${1}); do
		IFS=' '
		rdep=(${rdep})

		# check if requested for exclusion through --exclude
		vdb-is_excluded exclude ${rdep[1]} ${pkg} && continue

		# need to skip entries that do not provide shared libraries but,
		# to know this, need to check what virtuals resolve to
		provides=false
		if [[ ${rdep[0]} == virtual/* ]]; then
			IFS=$'\n'
			for vrdep in $(vdb-get_deps "${rdep[0]}" - RDEPEND); do
				if vdb-is_providing ${vrdep%% *}; then
					provides=true
					break
				fi
			done
		elif vdb-is_providing ${rdep[0]}; then
			provides=true
		fi
		${provides} || continue

		# if --no-overbind, discard subslot if vdb's subslot is 0
		if ! ${OPT[overbind]}; then
			[[ $(vdb-get_subslot ${rdep[0]}) == 0 ]] && rdep[3]=0
		fi

		# if --no-extra, exclude if not found in vdb-get_libneed's output
		if ! ${OPT[extra]} || vdb-is_excluded exclude-extra ${rdep[1]} ${pkg}; then
			[[ ${need} == *${rdep[1]}* ]] || continue
		fi

		echo "${rdep[1]}$(vdb-get_expected_slot ${rdep[1]} ${rdep[2]} ${rdep[3]} ${pkg} ${prebuilt})"
	done | sort || die "sort failed"
}

# vdb-get_libdiff_unified <CATEGORY/PN>
#	Echoes difference between vdb-get_libdeps and vdb-get_libneed,
#	or nothing if no changes.
vdb-get_libdiff() {
	local f1=($(vdb-get_libdeps ${1})) f2=($(vdb-get_libneed ${1}))

	# insert blank line if a line isn't indentical minus slot
	# same | same
	# diff <
	#      > diff
	# FIXME: this is terrible
	local -i i j
	local g1=f1 g2=f2
	if (( ${#f1[@]} < ${#f2[@]} )); then
		g1=f2
		g2=f1
	fi
	eval "
		for ((i=0; i < \${#${g1}[@]}; i++)); do
			for ((j=i; j < \${#${g2}[@]}; j++)); do
				if [[ \${${g1}[i]%:*} == \${${g2}[j]%:*} ]]; then
					(( i == j )) || ${g1}=(\"\${${g1}[@]:0:\${i}}\" '' \"\${${g1}[@]:\${i}}\")
					continue 2
				fi
			done
			${g2}=(\"\${${g2}[@]:0:\${i}}\" '' \"\${${g2}[@]:\${i}}\")
		done
	"

	# create combined output
	local -i len=0
	local o mark changes=false
	for ((i=0; i < ${#f1[@]}; i++)); do
		if [[ ${f1[i]} == ${f2[i]} ]]; then
			${OPT[full]} || continue
			mark=' '
		elif [[ ${f1[i]%:*} == ${f2[i]%:*} ]]; then
			mark='|'; changes=true
		elif [[ ! ${f1[i]} ]]; then
			mark='>'; changes=true
		else
			mark='<'; changes=true
		fi
		(( ${#f1[i]} > len )) && len=${#f1[i]}
		o[$((i*2))]=${f1[i]}
		o[$((i*2+1))]="${mark} ${f2[i]}"
	done

	${changes} || return 1

	printf -v o "%-${len}s %s\n" "${o[@]}"

	# colorize, done last so not considered for alignment
	local s1s s1sc s2s s2sc
	if ${OPT[color]}; then
		local -A c
		c[n]=$(echo -e '\e[0m')
		c[r]=$(echo -e '\e[31m')
		c[g]=$(echo -e '\e[32m')
		c[y]=$(echo -e '\e[33m')
		c[a]=$(echo -e '\e[90m')
		local IFS=$'\n'
		for o in ${o}; do
			if [[ ${o} == *\|* ]]; then
				s1=${o%|*}; s1s=; s1sc=
				s2=${o#*|}; s2s=; s2sc=
				if [[ ${s1} == *:* ]]; then
					s1s=:${s1#*:}
					s1s=${s1s%% *}
				fi
				if [[ ${s2} == *:* ]]; then
					s2s=:${s2#*:}
				fi

				i=0
				while [[ ${s1s:${i}} || ${s2s:${i}} ]]; do
					if [[ ${s1s:${i}:1} == ${s2s:${i}:1} ]]; then
						s1sc+=${c[a]}${s1s:${i}:1}
						s2sc+=${c[a]}${s2s:${i}:1}
					else
						s1sc+=${c[r]}${s1s:${i}:1}
						s2sc+=${c[g]}${s2s:${i}:1}
					fi
					((i++))
				done

				o="${c[a]}${s1//${s1s}/${s1sc}}${c[y]}|${c[a]}${s2//${s2s}/${s2sc}}${c[n]}"
			elif [[ ${o} == *\<* ]]; then
				o=${c[r]}${o}${c[n]}
			elif [[ ${o} == *\>* ]]; then
				o=${c[g]}${o}${c[n]}
			else
				o=${c[a]}${o}${c[n]}
			fi
			echo "${o}"
		done
	else
		echo "${o%$'\n'}"
	fi
}

# vdb-get_libdiff_unified <CATEGORY/PN>
#	Same as vdb-get_libdiff but uses `diff -U` for output
vdb-get_libdiff_unified() {
	local diff context=0

	${OPT[full]} && context=9999

	diff=$(
		diff -U${context} \
			<(vdb-get_libdeps ${1}) \
			<(vdb-get_libneed ${1}) \
			| grep -v '@@\|---\|+++'
		[[ ${PIPESTATUS[*]} == [01]\ [01] ]] || die "diff failed for ${1}"
	)

	[[ ${diff} ]] || return 0

	local IFS=$'\n' line color
	for line in ${diff}; do
		case ${line:0:1} in
			+) color=32;;
			-) color=31;;
			*) color=90;;
		esac
		if ${OPT[color]}; then
			printf "\e[${color}m%s\e[0m\n" "${line}"
		else
			echo "${line}"
		fi
	done
}

# vdb-get_libneed <CATEGORY/PF>
# 	Echos package list providing shared libraries based
#	on <CATEGORY/PF>'s vdb REQUIRES.
#	- If a virtual is used, attempts to list it instead of real package.
declare -A VDB_LIBNEED=() VDB_LIBNEED_SET=()
vdb-get_libneed() {
	# this function is normally ran twice, save last output
	if [[ ! ${VDB_LIBNEED_SET[${1}]+x} ]]; then
		VDB_LIBNEED[${1}]=$(_vdb-get_libneed ${1})
		VDB_LIBNEED_SET[${1}]=y
	fi
	[[ ${VDB_LIBNEED[${1}]} ]] && echo "${VDB_LIBNEED[${1}]}"
}
_vdb-get_libneed() {
	[[ -e ${VDB}/${1}/REQUIRES ]] || return 0 # no libs

	local prebuilt=
	vdb-is_prebuilt ${1} && prebuilt=prebuilt

	local pkg=$(vdb-get_pf2pn ${1})

	# read REQUIRES and strip excluded libraries
	local -a req=()
	for entry in $(
		sed 's/[^ ]*: //g' < "${VDB}"/${1}/REQUIRES \
			|| die "failed to get dependencies from REQUIRES for '${1}'"); do
		vdb-is_excluded exclude-lib ${entry%.so*}.so ${pkg} || req+=(${entry})
	done
	(( ${#req[@]} )) || return 0 # all libs excluded

	# use qfile to find providers (not best if more than one, but usually fine)
	local IFS dep entry slot subslot virtual
	for entry in $(qfile -CqvP "${req[@]}" | sort | uniq || die "qfile failed for '${1}'"); do
		dep=$(vdb-get_pf2pn "${entry}")

		# check rdepend for virtuals and the the virtual's rdepend for this dep
		IFS=$'\n'
		for virtual in $(vdb-get_deps "${1}" "virtual/*"); do
			IFS=' '
			virtual=(${virtual})

			# special exception for mesa "providing" libglvnd (not really)
			if [[ $(vdb-get_deps "${virtual%% *}" "${dep}" RDEPEND) ]] ||
				[[ ${dep} == media-libs/libglvnd && ${virtual[1]} == virtual/opengl ]]; then
				entry=${virtual[0]}
				dep=${virtual[1]}
				break
			fi
		done

		# with final cat/pn, check if requested for exclusion through --exclude
		vdb-is_excluded exclude ${dep} ${pkg} && continue

		# get SLOT information
		slot=0; subslot=0
		if [[ -e ${VDB}/${entry}/SLOT ]]; then
			slot=$(<"${VDB}"/${entry}/SLOT) || die "failed to read slot for '${entry}'"
			if [[ ${slot} == */* ]]; then
				subslot=${slot#*/}
				slot=${slot%/*}
			fi
		fi

		echo "${dep}$(vdb-get_expected_slot ${dep} ${slot} ${subslot} ${pkg} ${prebuilt})"
	done | sort | uniq || die "sort/uniq failed"
}

# vdb-get_deps <CATEGORY/PF> [glob|-] [DEPEND|BDEPEND]
#	Echos vdb's RDEPEND as "CATEGORY/PF CATEGORY/PN SLOT SUBSLOT"
#	- For || ( ) deps, only installed version is shown.
#	- If slot is '*', will be converted to vdb's current slot
#	- When unspecified, SLOT/SUBSLOT will default to 0
#	- if glob is set, only return matching dependencies (- to pass)
#   - if *DEPEND is set, match against it rather than ${OPT[depend]}
vdb-get_deps() {
	local deptype=${OPT[depend]}
	(( ${#} >= 3 )) && deptype=${3}

	[[ -e ${VDB}/${1}/${deptype} ]] || return 0

	local atom entry rdep IFS=' '
	local -i group=0
	local -A deps
	for rdep in $(cat "${VDB}"/${1}/${deptype} || die "failed to read ${deptype} for '${1}'"); do
		[[ ${rdep} == !* ]] && continue # ignore blockers

		# Handle ( ) and || ( ) deps loosely (allow missing deps within a group)
		[[ ${rdep} == '||' ]] && continue
		if [[ ${rdep} == '(' ]]; then
			(( group++ ))
			continue
		fi
		if [[ ${rdep} == ')' ]]; then
			(( group-- ))
			continue
		fi

		# check for [glob] against atom
		# note: would prefer to do this post-qatom but this gets slow
		[[ ${#} -ge 2 && ${2} != - ]] && eval "[[ \${rdep} != *${2}* ]] && continue"

		# find vdb entry for dep
		entry=$(vdb-get_dep2entry "${rdep}")

		if [[ ! ${entry} ]]; then
			(( group )) && continue
			${OPT[ignore-uninstalled]} && continue
			die "no installed provider in vdb for '${rdep}' (may be due to binpkgs ordering)"
		fi

		# ${rdep} can be something like ">=dev-libs/libevent-2.0:0/2.1-7=[threads]"
		# use qatom to split without direct parsing here (esp versions)
		atom=($(vdb-get_atomf '%{CATEGORY}/%{PN} %{SLOT} %{SUBSLOT}' "${rdep}"))
		if [[ ${atom[1]} == '<unset>' ]]; then
			# qatom converts :* to <unset> even if set, check against ${rdep}
			if [[ ${atom[1]} == *:\** ]]; then
				atom[1]=$(vdb-get_slot ${entry})
			else
				atom[1]=0
			fi
		fi
		if [[ ${atom[2]} == '<unset>' ]]; then
			atom[2]=0
		elif [[ ${atom[2]: -1} == = ]]; then
			atom[2]=${atom[2]%=}

			# pretend have non-zero subslot if bound
			[[ ${atom[2]} == 0 ]] && atom[2]=1
		fi

		# in case of duplicates, keep the one that defines a subslot
		if [[ ${deps[${entry}]:-} ]]; then
			rdep=(${deps[${entry}]:-})
			[[ ${atom[2]} == 0 || ${rdep[2]} != 0 ]] && continue
		fi

		deps[${entry}]="${entry} ${atom[*]}"
	done

	printf "%s" "${deps[@]/%/$'\n'}"
}

# vdb-get_slot <CATEGORY/PF>
#	Echos slot from vdb
vdb-get_slot() {
	local slot

	if [[ -e "${VDB}"/${1}/SLOT ]]; then
		slot=$(<"${VDB}"/${1}/SLOT) || die "failed to read slot for '${1}'"
		echo ${slot%/*}
		return
	fi

	echo 0
}

# vdb-get_subslot <CATEGORY/PF>
#	Echos subslot from vdb
vdb-get_subslot() {
	local subslot

	if [[ -e "${VDB}"/${1}/SLOT ]]; then
		subslot=$(<"${VDB}"/${1}/SLOT) || die "failed to read subslot for '${1}'"
		if [[ ${subslot} == */* ]]; then
			echo ${subslot%*/}
			return
		fi
	fi

	echo 0
}

# vdb-is_excluded <exclude-*|ignore> [CATEGORY/PN(dep) or lib.so] <CATEGORY/PN(pkg)>
#	Return true if dep shouldn't be considered when checking pkg
#	Types are based on --exclude* options and qa-vdb.* config files
#	(dep) can be missing for ignore type
vdb-is_excluded() {
	[[ ${OPT[${1}]} ]] || return 1

	# strip = prefixes if matches package to activate them
	# eval is needed to enable globs
	eval "[[ \${2%:*} =~ ^(${OPT[${1}]//${3:-nil}=/})$ ]]"
}

# vdb-is_prebuilt <CATEGORY/PF>
#	Return true if QA_PREBUILT is set at all
#	TODO: verify contents/regexes for partially prebuilt situations
vdb-is_prebuilt() {
	[[ -e ${VDB}/${1}/QA_PREBUILT ]]
}

# vdb-is_providing <CATEGORY/PF>
#	Return true if providing shared libraries
vdb-is_providing() {
	[[ -e ${VDB}/${1}/PROVIDES ]] || return 1

	# This file can contain modules and executables we aren't
	# interested in and modules sometime have "lib*.so" names.
	# To rule them out, check if one of its file is known to ldconfig.
	local provided IFS=' '
	for provided in $(cat "${VDB}"/${1}/PROVIDES || die "could not read PROVIDES for ${1}"); do
		[[ ${provided} == *.so* ]] || continue

		if [[ ${LDCACHE} ]]; then
			[[ ${LDCACHE} == *$'\n'${provided%.so*}.so$'\n'* ]] && return 0

			# special exception for haskell as it doesn't use linker path
			[[ ${provided} == *-ghc* ]] && return 0
		else
			return 0 # ignore missing cache
		fi
	done
	return 1
}

# vdb-print_libdiff <CATEGORY/PF>
# 	Prints output of vdb_get_libdiff (if any) with header
vdb-print_libdiff() {
	local diff

	if ${OPT[unified]}; then
		diff=$(vdb-get_libdiff_unified ${1})
	else
		diff=$(vdb-get_libdiff ${1})
	fi

	if [[ ${diff} ]]; then
		msg "QA: detected possibly incorrect ${OPT[depend]} (${1})"
		msg "${diff}"

		if ! [[ ${OPT[exclude]} || ${OPT[exclude-slot]} || ${OPT[exclude-bind]} || ${OPT[exclude-extra]} || ${OPT[exclude-lib]} ]] &&
			${OPT[default-exclude]}; then
			msg "Note: no exclusions set (e.g. glibc/gcc), please verify configuration files"
		fi
	elif ${OPT[confirm]}; then
		msg "QA: ${OPT[depend]} is as expected, no issues here (${1})"
	fi
}

# vdb-set_exclude <exclude-*>
#   Load exclude configs and prepare supplied ${OPT[exclude*]} for use
vdb-set_exclude() {
	if ${OPT[default-exclude]}; then
    	local -a conf=()
		local file=qa-vdb.${1}

		if [[ ${OPT[confdir]} ]]; then
			[[ -r ${OPT[confdir]}/${file} ]] && conf=("${OPT[confdir]}/${file}")
		else
			[[ -r ${OPT[sysconfdir]}/${file} ]] && conf=("${OPT[sysconfdir]}/${file}")
			[[ -r ${OPT[userconfdir]}/${file} ]] && conf+=("${OPT[userconfdir]}/${file}")
		fi

		if [[ ${conf[*]} ]]; then
			OPT[${1}]+=,$(sed 's/#.*//' "${conf[@]}" | tr '\r\n' ',,' \
				|| die "failed reading configuration files")
		fi
	fi

	# create a simple a|b|c, escape +/., and * -> .*
	OPT[${1}]=$(sed \
		-e 's/[^A-Za-z0-9_/.+*,=-]//g' \
		-e 's/,,*/|/g;s/^|//;s/|$//' \
		-e 's/+/\\+/g;s/\./\\./g;s/\*/.*/g' \
		<<< "${OPT[${1}]}") || die "sed failed"
}

# vdb-set_ldcache
#	Load list of libraries known to ldconfig (optional)
vdb-set_ldcache() {
	local ldconfig IFS=$'\n'
	ldconfig=($(type -P ldconfig /sbin/ldconfig /usr/sbin/ldconfig 2>/dev/null))
	if (( ! ${#ldconfig[@]} )); then
		LDCACHE=
		return
	fi

	local args=(-N -v)
	if [[ ${EROOT} ]]; then
		args+=(
			-f "${EROOT}"/etc/ld.so.conf
			-C "${EROOT}"/etc/ld.so.cache
		)
	fi

	LDCACHE="
		$(${ldconfig[0]} "${args[@]}" 2>/dev/null | \
			sed '/: /d;s/\.so.*/.so/;s/.*\t//' | sort | uniq \
			|| die "ldconfig failed")
	"
}

# vdb-set_vdb
#	Set VDB variable to vdb's path (usually /var/db/pkg)
vdb-set_vdb() {
	VDB=$(portageq vdb_path) || die "portageq failed to return vdb path"
	[[ -d ${VDB} ]] || die "found VDB (${VDB}) but does not appear valid"

	export Q_VDB=${VDB#${ROOT}} # ensure q tool use right vdb
}

# vdb-init
#	Init various settings
vdb-init() {
	vdb-set_vdb
	vdb-set_ldcache
	vdb-set_exclude exclude
	vdb-set_exclude exclude-slot
	vdb-set_exclude exclude-bind
	vdb-set_exclude exclude-extra
	vdb-set_exclude exclude-lib
	vdb-set_exclude ignore
}

# vdb-skip_ignore <CATEGORY/PF>
#	Exit if CATEGORY/PF is matched by qa-vdb.ignore config file
#	Do so silently unless OPT[confirm] is set
vdb-skip_ignore() {
	local catpn=$(vdb-get_atomf "%{CATEGORY}/%{PN}" ${1})

	if vdb-is_excluded ignore ${catpn}; then
		${OPT[confirm]} && msg "QA: ${1} was skipped due to being in qa-vdb.ignore"
		exit 0
	fi
}

vdb-init

vdbentry=$(vdb-get_entry "${1}")

vdb-skip_ignore ${vdbentry}
vdb-print_libdiff ${vdbentry}

:

# vim: ts=4
