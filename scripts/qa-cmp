#!/usr/bin/env bash
version() { echo "${0##*/} @version@"; exit; }
usage() {
	cat <<-EOF
		Usage: ${0##*/} <atom|image> [atom2|image2]

		Compares an installation image (i.e. \${PORTAGE_TMPDIR}/[...]/image/),
		with either another image or the currently installed system copy.

		Arguments can either be a path to the image, or an atom representing it.
		If atom is imprecise (i.e. no version), or only one is given, then will
		guess the right versions based on timestamps (older with newest).

		Options:
		  -f, --no-filelist     Do not print filelist differences
		  -s, --no-soname       Do not print SONAME differences
		  -a, --no-abidiff      Do not print per-libraries abidiff
		  -z, --no-size         Do not print size differences when above threshold
		  -r, --no-report       Do not report statistics at the end
		  -x, --no-compare      Short for all of the above (intended for --single-*)
		(unless -r/-x, report will still have statitics for disabled options)

		  -T, --size-thres=%    Size difference percentage at which to display it
		                        (default: 10.0%, 0 to always display)

		  -B, --full-abidiff    Show complete abidiff output
		  -d, --quiet-nodebug   Do not warn if missing debug for abidiff (unless -W)

		  -I, --image-only      When guessing what to compare, ignore system's copy.
		                        (simplifies comparing two images)

		  -K, --ver-keep        Do not replace filelist's versions in names by <snip>
		  -O, --ver-dironly     Limit filelist version replacements to directories
		(default is to try to prevent showing uninteresting version-only changes)

		  -M, --allow-missing   Do nothing and exit normally if lacking a 2nd image
		                        (intended for automated scripts)

		  -W, --confirm         Show all statistics even if no changes as confirmation

		  -F, --single-filelist Show full filelist for latest
		  -S, --single-soname	Show full soname list for latest
		  -Z, --single-size     Show size for latest
		  -L, --single-all      Short for --single-{filelist,soname,size}
		  -U, --single-auto     Auto-disable specified --single-* if two images
		                        (--single-* options can function with a single image)

		  -c, --no-color        Disable use of colors

		  -h, --help            Display usage information and exit
		      --version         Display version information and exit

		*Abidiff Notes*
		Requires debug symbols for full report (FEATURES=splitdebug and -g).
		Report showing '[BREAKING]' doesn't necessarily mean it's breaking
		revdeps without rebuilds, but it warrants testing them while built
		against old version. Order matters, downgrading often breaks ABI.

		*Portage Integration*
		Can be integrated by using ${EROOT}/etc/portage/bashrc, either by using the
		example ${ROOT}@datadir@/bashrc or by manually adding:
		 >  source @datadir@/${0##*/}.bashrc
		 >  post_pkg_preinst() {
		 >      qa-cmp_post_pkg_preinst
		 >  }

		bashrc environment options (export/make.conf/package.env):
		  QA_CMP=y | =n         Enable or disable, can also use IWDT_ALL=y | =n
		  QA_CMP_CMD=${0##*/}     This script, needs to be changed if not in PATH
		  QA_CMP_ARGS=          Extra arguments to pass, see options above
		  QA_CMP_LOG=ewarn      Portage log level command to use for output
	EOF
	exit
}

set -Efuo pipefail
trap '(( ${?} != 166 )) || exit 166' ERR
trap '(( BASH_SUBSHELL )) && exit 166 || exit 1' USR1
trap 'exit 0' USR2
die() {
	local sig=1
	if [[ ${1} == -0 ]]; then
		sig=2
	else
		echo "Error: ${*} (${FUNCNAME[1]/#main/${0##*/}}:${BASH_LINENO[0]})" >&2
	fi
	local IFS=' '; eval "set -- \$(</proc/${BASHPID}/stat)"
	(( ! ${4:-} || ${4} == PPID || ${4} == ${$} )) || kill -USR1 ${4}
	kill -USR${sig} ${$}; exit 166
}
msg() { local IFS=$'\n'; set -- "${*}"; printf "%s\n" "${@}"; }
: @eprefix@
: ${ROOT=''}; ROOT=${ROOT%/}
: ${EROOT=${ROOT}${EPREFIX:-}}; EROOT=${EROOT%/}
export ROOT EROOT EPREFIX

# Dependencies:
#	app-misc/pax-utils (scanelf)
#	app-portage/portage-utils (qatom,qlist)
#	dev-util/libabigail (abidiff) [optional]
#	sys-apps/coreutils (cat,cut,head,readlink,sort,tail,uniq)
#	sys-apps/diffutils (diff)
#	sys-apps/file (file)
#	sys-apps/grep (grep)
#	sys-apps/portage (portageq)
#	sys-apps/util-linux (getopt)
type cat cut diff file getopt grep head portageq qatom qlist readlink \
	scanelf sort tail uniq >/dev/null || die "missing dependencies"

declare -A OPT
OPT[filelist-diff]=true
OPT[soname-diff]=true
OPT[abi-diff]=true
OPT[size-diff]=true
OPT[report]=true
OPT[compare]=true
OPT[size-thres]=1000
OPT[full-abidiff]=false
OPT[warn-debug]=true
OPT[image-only]=false
OPT[ver-keep]=false
OPT[ver-dironly]=false
OPT[allow-missing]=false
OPT[confirm]=false
OPT[single]=false
OPT[single-filelist]=false
OPT[single-soname]=false
OPT[single-size]=false
OPT[single-auto]=false
OPT[color]=true

eval set -- $(getopt \
	-o hfsazrxT:BdIKOMWFSZLUc \
	-l help,version,no-filelist,no-soname,no-abidiff,no-size,no-report,no-compare,size-thres:,full-abidiff,quiet-nodebug,image-only,ver-keep,ver-dironly,allow-missing,confirm,single-filelist,single-soname,single-size,single-all,single-auto,no-color \
	-- "$@" || die "invalid arguments")
while (( ${#} )); do
	case ${1} in
		-h|--help) usage;;
		   --version) version;;
		-f|--no-filelist) OPT[filelist-diff]=false;;
		-s|--no-soname) OPT[soname-diff]=false;;
		-a|--no-abidiff) OPT[abi-diff]=false;;
		-z|--no-size) OPT[size-diff]=false;;
		-r|--no-report) OPT[report]=false;;
		-x|--no-compare) OPT[compare]=false;;
		-T|--size-thres)
			printf -v 'OPT[size-thres]' '%.2f' "${2%\%}" 2>/dev/null
			OPT[size-thres]=${OPT[size-thres]/./}
			shift
		;;
		-B|--full-abidiff) OPT[full-abidiff]=true;;
		-d|--quiet-nodebug) OPT[warn-debug]=false;;
		-I|--image-only) OPT[image-only]=true;;
		-K|--ver-keep) OPT[ver-keep]=true;;
		-O|--ver-dironly) OPT[ver-dironly]=true;;
		-M|--allow-missing) OPT[allow-missing]=true;;
		-W|--confirm) OPT[confirm]=true;;
		-F|--single-filelist) OPT[single-filelist]=true;;
		-S|--single-soname) OPT[single-soname]=true;;
		-Z|--single-size) OPT[single-size]=true;;
		-L|--single-all)
			OPT[single-filelist]=true
			OPT[single-soname]=true
			OPT[single-size]=true
		;;
		-U|--single-auto) OPT[single-auto]=true;;
		-c|--no-color) OPT[color]=false;;
		--) shift; break;;
	esac
	shift
done
(( ${#} >= 1 )) || die "no atom/image specified, see \`${0##*/} --help\`"
(( ${#} <= 2 )) || die "too many atom/image given, see \`${0##*/} --help\`"

${OPT[single-filelist]} || ${OPT[single-soname]} || ${OPT[single-size]} \
	&& OPT[single]=true

! ${OPT[filelist-diff]} && ! ${OPT[soname-diff]} && ! ${OPT[abi-diff]} \
	&& ! ${OPT[size-diff]} && ! ${OPT[report]} \
	&& OPT[compare]=false

# cmp-get_atomf <format> <atom>
#   Echos <atom> based on <format> using qatom -F.
cmp-get_atomf() {
	qatom -CqF "${1}" -- "${@:2}" || die "q command failed: qatom -CqF ${*}"
}

# cmp-get_compare2readable <compare>
#	Echoes a cmp-get_tocompare converted value to be more readable
cmp-get_compare2readable() {
	if [[ ${1} =~ .*/([^/]*/[^/]*/image) ]]; then
		# this may not always be category/version but is a fair to be shorter
		echo "${BASH_REMATCH[1]}"
	else
		echo "${1}"
	fi
}

# cmp-get_filelist <compare>
#	Echoes sorted filelist from a cmp-get_tocompare value
#	First three lines are specially set to:
#		1. ${PVR} 2. prefix/ 3. size in bytes
#	usr/lib/debug/ excluded for simplification
cmp-get_filelist() {
	local -i size
	if [[ ${1:0:1} == = ]]; then
		echo $(cmp-get_atomf "%{PVR}" "${1}")
		echo "${ROOT}"/

		local vdb=$(cmp-get_vdb)
		size=$(<"${vdb}/${1#=}"/SIZE) \
			|| die "failed to read '$(cmp-get_vdb)/${1#=}/SIZE'"
		echo ${size}

		Q_VDB=${vdb#${ROOT}} \
			qlist -Cqe "${1}" | cut -d/ -f2- | grep -v '^usr/lib/debug/' | sort
		[[ ${PIPESTATUS[*]} == '0 0 '[01]' 0' ]] || die "qlist failed for '${1}'"
	else
		# images may not have any information about what they are, but if used
		# normally the path will have ${CATEGORY}/${PF} given by image2atomf
		local pv=$(cmp-get_image2atomf "%{PVR}" "${1}")
		if [[ ! ${pv} ]]; then
			# version is an annoyance mostly with docdir, try to check if there
			local dirs=("${1}"/usr/share/doc/*)
			if (( ${#dirs[@]} )); then
				pv=$(cmp-get_atomf "%{PVR}" "${dirs[0]##*/}")
			else
				pv="<unset>"
			fi
		fi
		echo ${pv}
		echo "${1}/"

		size=$(<"${1%/image}"/build-info/SIZE) \
				|| die "failed to read '${1%/image}/build-info/SIZE', failed build image?"
		echo ${size}

		find "${1}" -path "${1}/usr/lib/debug" -prune -o -not -type d -printf '%P\n' | sort \
			|| die "find failed for '${1}'"
	fi
}

# cmp-get_image2atomf <format> <normalized-image>
#	Echoes cmp-get_atomf for an image returned by cmp-get_normalized_image()
#	Returns false and an empty string if not contained within it
cmp-get_image2atomf() {
	local img=${2}

	[[ -d ${img} ]] || return 1

	img=${img#$(cmp-get_tmp)/}
	img=${img%/image}

	if [[ ${img} =~ ^[^/]*/[^/]*$ ]]; then
		cmp-get_atomf "${1}" "${img}"
		return
	fi

	return 1
}

# cmp-get_images <atom>
#	Echos 1-3 images full path and/or installed =CATEGORY/PF from newest to older
#	First exact matches, then cat/pn:slot (if specified) then cat/pn
cmp-get_images() {
	{
		local atom dir match slot
		local -i ts

		# convert atom to something we can use
		if [[ ${1} == */* ]]; then
			match=${1}
		else
			# ${CATEGORY} is missing, ask portage for a match
			match=$(cmp-get_visible "${1}")
			match+=$(cmp-get_atomf "%[SLOT]" "${1}") # keep explicit slot if given
		fi

		local IFS=' ' # may be set to $'\n'
		atom=($(cmp-get_atomf "%{CATEGORY} %{PN} %[SLOT]" "${match}"))
		atom[2]=${atom[2]:+:${atom[2]}}
		unset IFS

		if ! ${OPT[image-only]}; then
			for match in "${1}" ${atom[0]}/${atom[1]}${atom[2]:-} ${atom[2]:+${atom[0]}/${atom[1]}}; do
				match=$(cmp-get_installed "${match}")
				if [[ ${match} ]]; then
					ts=$(<"$(cmp-get_vdb)/${match}"/BUILD_TIME) \
						|| die "failed to read '$(cmp-get_vdb)/${match}/BUILD_TIME'"
					echo "${atom[2]:-:0} ${ts} =${match}"
					break
				fi
			done
		fi

		set +f; shopt -s nullglob
		for dir in "$(cmp-get_tmp)/${atom[0]}"/*; do
			# need to atomf the directory too, ${PN} can contain -
			match=$(cmp-get_atomf "%{PN}" "${atom[0]}/${dir##*/}")
			[[ ${atom[1]} == "${match}" ]] || continue # mismatch

			if [[ ${atom[2]:-} ]]; then
				# try to skip wrong slots
				[[ -e "${dir}"/build-info/SLOT ]] || continue # likely a failed image
				slot=$(<"${dir}"/build-info/SLOT) \
					|| die "failed to read '${dir}/build-info/SLOT'"
				[[ ${atom[2]} == :${slot%/*} ]] || continue
			fi

			[[ -e "${dir}"/build-info/BUILD_TIME ]] || continue # likely a failed image
			ts=$(<"${dir}"/build-info/BUILD_TIME) \
				|| die "failed to read '${dir}/build-info/BUILD_TIME'"

			dir+=/image
			[[ -d "${dir}" ]] || die "found unusable image at '${dir}'"

			echo "${atom[2]:-:0} ${ts} ${dir}"
		done
		set -f; shopt -u nullglob
	} | sort -nr | head -n 3 | cut -d' ' -f3- || die "failed to get images for '${1}'"
}

# cmp-get_installed <atom>
#	Echoes CATEGORY/PF best match for installed atom, or empty string if none
declare -A CMP_INSTALLED=() CMP_INSTALLED_SET=()
cmp-get_installed() {
	if [[ ! ${CMP_INSTALLED_SET[${1}]+x} ]]; then
		# note: unlike best_visible, does not return false if no match
		CMP_INSTALLED[${1}]=$(portageq match "${EROOT:-/}" "${1}" | tail -n 1) \
			|| die "portageq match failed for '${1}'"
		CMP_INSTALLED_SET[${1}]=y
	fi

	echo "${CMP_INSTALLED[${1}]}"
}

# cmp-get_makereport <format> <stat> <color> <current-report>
#	Echos report entry if non-zero (or if --confirm) using <format>/<color>
#	If stat is >=, format can have %d to display <stat>
#	If stat is -1, close report
cmp-get_makereport() {
	if [[ ${2} == -1 ]]; then
		if [[ ${4} ]] || ${OPT[confirm]}; then
			if ${OPT[color]}; then
				printf -- "\e[${3}m${1}(\e[0m%s\e[${3}m)\e[0m\n" "${4}"
			else
				printf -- "${1}(%s)\n" "${4}"
			fi
		fi
	elif (( ${2} )) || ${OPT[confirm]}; then
		if [[ ${4} ]]; then
			if ${OPT[color]}; then
				printf -- "%s\e[90m,\e[0m" "${4}"
			else
				printf -- "%s," "${4}"
			fi
		fi
		if ${OPT[color]}; then
			printf -- "\e[${3}m${1}\e[0m" "${2}"
		else
			printf -- "${1}" "${2}"
		fi
	else
		printf -- "%s" "${4}"
	fi
}

# cmp-get_normalized_image <atom|image>
#	Echoes image full path for an exact image or atom
#	Returns 1 and an empty string if could not find an exact match
#	Returns 2 if argument may have been intended as an atom
cmp-get_normalized_image() {
	local image=${1} atom=0

	if [[ -d ${image} ]]; then
		image=$(readlink -e -- "${image}" || die "readlink -e failed for '${image}'")
	elif [[ -d $(cmp-get_tmp)/${image#=} ]]; then
		image=$(cmp-get_tmp)/${image#=} # exact tmp dir match
		atom=2
	elif [[ ${image:0:1} == = && ${image} != */* ]]; then
		# likely supplied a mostly-exact =package-0.0.0 without category, ask portageq
		image=$(cmp-get_tmp)/$(cmp-get_visible "${1}")
		[[ -d ${image} ]] || return 1
		atom=2
	else
		return 1
	fi

	# hopefully image itself does not have this dir
	[[ -d ${image}/image ]] && image+=/image

	echo "${image}"
	return ${atom}
}

# cmp-get_scanelf <args>
#	Wrapper for scanelf to echo `sort | uniq` list and check for errors
cmp-get_scanelf() {
	scanelf -q "${@}" | sort | uniq || die "scanelf failed with args: '-q ${*}'"
}

# cmp-get_shared <possible libraries...>
#	Echoes back shared libraries from the given list.
#	Symbolic links will also be skipped as the non-link library is
#	expected to be in the list.
cmp-get_shared() {
	unset IFS

	local -a so=()
	while (( ${#} )); do
		# trim list for less checks, not interested in obscure not-.so
		if [[ ${1} == *.so* && ! -L ${1} ]]; then
			[[ -r ${1} ]] || die "'${1}' is not readable"
			so+=("${1}")
		fi
		shift
	done

	(( ${#so[@]} )) || return 0

	file -i0 -- "${so[@]}" | grep -aF 'x-sharedlib' | cut -d '' -f1
	[[ ${PIPESTATUS[*]} == '0 '[01]' 0' ]] \
		|| die "file check for shared libraries failed"
}

# cmp-get_tmp
#	Echos portage's tmpdir or die if basic sanity checks (intended to
#	give less confusing errors) failed
#
#	Not set on init given this may not always be needed, e.g. if image
#	directories are in ${HOME} then ${PORTAGE_TMPDIR} doesn't matter
CMP_TMP=
cmp-get_tmp() {
	# cache given portageq invocation is not the fastest thing
	if [[ ${CMP_TMP} ]]; then
		echo "${CMP_TMP}"
		return
	fi

	if [[ ${PORTAGE_TMPDIR:-} ]]; then
		CMP_TMP=${PORTAGE_TMPDIR}
	else
		CMP_TMP=$(portageq envvar PORTAGE_TMPDIR || die "portageq failed to return PORTAGE_TMPDIR")
	fi
	[[ ${CMP_TMP} ]] || die "could not determine PORTAGE_TMPDIR"

	CMP_TMP+=/portage

	[[ -d ${CMP_TMP} ]] || die "'${CMP_TMP}' is not a directory"

	# use readlink to normalize (no symlinks, double //, etc..)
	CMP_TMP=$(readlink -e -- "${CMP_TMP}" || die "readlink -e failed for '${CMP_TMP}'")

	# portage often uses 700 for tmp/cat/pkg which can lead to confusing errors,
	# e.g. -d tmp/cat/pkg/image not being a directory
	set +f; shopt -s nullglob
	local dirs=("${CMP_TMP}"/*/*)
	if [[ ${#dirs[@]} != 0 && ! -r ${dirs[0]} ]]; then
		die "permission denied for image dirs under '${CMP_TMP}'"
	fi
	set -f; shopt -u nullglob

	echo "${CMP_TMP}"
}

# cmp-get_tocompare <atom|image> [atom2|image2]
#	Echos what to compare based on rough arguments, first line being
#	oldest, and 2nd line the newest to compare with
#	Will either be a full path to the image, or =CATEGORY/PF if installed
cmp-get_tocompare() {
	local -a i1 i2=()
	local IFS=$'\n'

	# Given allow user to specify all sort of things (atom, image path,
	# specific versions or not), need to do a bit of messy guesswork to
	# find what to compare. Optimally would be two arguments where
	# cmp-get_normalized_image returned the exact match.
	i1[0]=$(cmp-get_normalized_image "${1}")
	case ${?} in
		1)	# no match, fallback to cat/pn search
			i1=($(cmp-get_images "${1}"))
		;;
		2)	# matched but if ${2} is same then one of them is meant
			# to match system (can't tell which), discard and search
			if [[ ${1} == ${2:-} ]]; then
				shift
				i1=($(cmp-get_images "${1}"))
			fi
		;;
	esac

	if (( ${#} == 2 )); then
		i2[0]=$(cmp-get_normalized_image "${2}")
		(( ${?} == 1 )) && i2=($(cmp-get_images "${2}"))
	elif (( ${#i1[@]} >= 2 )); then
		# use first image as newest (in i2), and 2nd as older (in i1)
		i2[0]=${i1[0]}
		i1[0]=${i1[1]}
	elif (( ${#i1[@]} )); then
		# last hope to try to find something to compare with by using
		# category/pn in the image path and checking if installed
		local catpn=$(cmp-get_image2atomf "%{CATEGORY}/%{PN}" "${i1[0]}")
		[[ ${catpn} ]] && i2=($(cmp-get_images "${catpn}"))
	fi

	# shift until i1[0] != i2[0]
	while (( ${#i1[@]} && ${#i2[@]} )) && [[ ${i1[0]} == "${i2[0]}" ]]; do
		if (( ${#i1[@]} >= ${#i2[@]} )); then
			i1=("${i1[@]:1}")
		else
			i2=("${i2[@]:1}")
		fi
	done

	if ! (( ${#i1[@]} && ${#i2[@]} )); then
		if ${OPT[single]}; then
			if (( ${#i2[@]} )); then
				echo "${i2[0]}"
				return
			elif (( ${#i1[@]} )); then
				echo "${i1[0]}"
				return
			fi
		fi

		if ${OPT[allow-missing]}; then
			die -0 # exit with 0
		elif (( ${#i1[@]} && ${#i2[@]} )); then
			die "could not find images for '${*}'"
		else
			die "found nothing to compare with, did you mean to use --single-*?"
		fi
	fi

	echo "${i1[0]}"
	echo "${i2[0]}"
}

# cmp-get_vdb
#	Echos portage's vdb path (similar to cmp-get_tmp)
CMP_VDB=
cmp-get_vdb() {
	if [[ ! ${CMP_VDB} ]]; then
		CMP_VDB=$(portageq vdb_path) || die "portageq vdb_path failed"
		[[ -d ${CMP_VDB} ]] || die "portageq returned '${CMP_VDB}' as VDB path which does not appear usable"
	fi
	echo "${CMP_VDB}"
}

# cmp-get_visible <atom>
#	Echoes CATEGORY/PF best visible for atom, or die if none
declare -A CMP_VISIBLE=() CMP_VISIBLE_SET=()
cmp-get_visible() {
	if [[ ! ${CMP_VISIBLE_SET[${1}]+x} ]]; then
		CMP_VISIBLE[${1}]=$(portageq best_visible "${EROOT:-/}" "${1}") \
			|| die "portageq best_visible failed for '${1}'"
		# empty string shouldn't happen as it returns false, but check anyway
		[[ ${CMP_VISIBLE[${1}]} ]] || die "portageq best_visible returned an empty string for '${1}'"
		CMP_VISIBLE_SET[${1}]=y
	fi

	echo "${CMP_VISIBLE[${1}]}"
}

# cmp-output_abi_diff
#	Add to OUTPUT abi differences between libraries of LIST_OLD and LIST_NEW
#	that share the same SONAME, requires to have run cmp-output_soname_diff
cmp-output_abi_diff() {
	if ! (( ${#SONAME_OLD[@]} || ${#SONAME_NEW[@]} )); then
		cmp-output_abi_diff_issue "N/A" 0 # no libraries
		return
	fi

	# create list of files that exist in both (aka unchanged soname)
	# SONAME_* entries are "soname.so.0 /path/to/file"
	local -i i j
	local -a old=() new=()
	for ((i=0; i < ${#SONAME_OLD[@]}; i++)); do
		for ((j=0; j < ${#SONAME_NEW[@]}; j++)); do
			if [[ ${SONAME_OLD[i]%% *} == "${SONAME_NEW[j]%% *}" ]]; then
				old+=("${SONAME_OLD[i]}")
				new+=("${SONAME_NEW[j]}")
			fi
		done
	done

	if ! (( ${#old[@]} || ${#new[@]} )); then
		cmp-output_abi_diff_issue "---" 0 # all sonames changed
		return
	fi

	if ! type abidiff &>/dev/null; then
		# if no abidiff, assume unwanted -- make this a semi-hidden warning
		cmp-output_abi_diff_issue "no-abidiff" 0
		return
	fi

	# abidiff has a tendency to output nothing and return 0 if no debug
	# info and --fail-no-debug-info doesn't change this last checked, but
	# --stats should always output something /if/ it's going to work
	# (this include a few changes it can find without debug info)
	# TODO?: do own check for debug to inform report may be incomplete
	local debugold=${LIST_OLD[1]}usr/lib/debug
	local debugnew=${LIST_NEW[1]}usr/lib/debug
	for ((i=0; i < ${#old[@]}; i++)); do
		output=$(abidiff --stats \
			--d1 "${debugold}" \
			--d2 "${debugnew}" \
			"${old[i]#* }" "${new[i]#* }" 2>&1)

		# ABIDIFF_ERROR = 1
		# ABIDIFF_USAGE_ERROR = 2
		# ABIDIFF_ABI_CHANGE = 4
		# ABIDIFF_ABI_INCOMPATIBLE_CHANGE = 8
		if (( ${?} & 3 )); then
			# give message for troubleshooting, but don't || die
			msg "${output} (${FUNCNAME[0]})"
			cmp-output_abi_diff_issue "FAIL" 1
			return
		fi

		if [[ ! ${output} ]]; then
			if ${OPT[warn-debug]}; then
				cmp-output_abi_diff_issue "nodebug" 1
			else
				cmp-output_abi_diff_issue "nodebug" 0
			fi
			return
		fi
	done

	local IFS=$'\n' errno line output report
	local -i add=0 chg=0 del=0 brk=0
	local -i fr fc fa vr vc va
	for ((i=0; i < ${#old[@]}; i++)); do
		output=$(abidiff \
			--d1 "${debugold}" \
			--d2 "${debugnew}" \
			"${old[i]#* }" "${new[i]#* }" 2>&1)
		errno=${?}
		if (( errno & 3 )); then
			msg "${output} (${FUNCNAME[0]})"
			cmp-output_abi_diff_issue "FAIL" 1
			return
		fi

		(( errno & 12 )) || continue # no changes

		if [[ ${output} =~ .*:\ ([0-9]+)\ Removed[^:]*,\ ([0-9]+)\ Changed[^:]*,\ ([0-9]+)\ Added.*:\ ([0-9]+)\ Removed[^:]*,\ ([0-9]+)\ Changed[^:]*,\ ([0-9]+)\ Added ]]; then
			fr=${BASH_REMATCH[1]}
			fc=${BASH_REMATCH[2]}
			fa=${BASH_REMATCH[3]}
			vr=${BASH_REMATCH[4]}
			vc=${BASH_REMATCH[5]}
			va=${BASH_REMATCH[6]}
		else
			# shouldn't(?) happen unless a libabigail bump changed things around
			cmp-output_abi_diff_issue "parse-error" 1
			return
		fi

		if [[ ${output} =~ .*:\ ([0-9]+)\ Removed[^:]*,\ ([0-9]+)\ Added[^:]*'not referenced by debug info'.*:\ ([0-9]+)\ Removed[^:]*,\ ([0-9]+)\ Added ]]; then
			fr+=${BASH_REMATCH[1]}
			fa+=${BASH_REMATCH[2]}
			vr+=${BASH_REMATCH[3]}
			va+=${BASH_REMATCH[4]}
		fi

		(( add+=fa+va ))
		(( del+=fr+vr ))
		(( chg+=fc+vc ))
		(( errno & 8 )) && brk+=1

		if ${OPT[abi-diff]}; then
			if ${OPT[color]}; then
				OUTPUT+=$(printf "   \e[90mABI:\e[35m %s\e[0m" "${old[i]%% *}")
			else
				OUTPUT+="   ABI: ${old[i]%% *}"
			fi
			report=$(cmp-get_makereport "+%d" ${fa} 32 "")
			report=$(cmp-get_makereport "~%d" ${fc} 33 "${report}")
			report=$(cmp-get_makereport "-%d" ${fr} 31 "${report}")
			report=$(cmp-get_makereport "func" -1 94 "${report}")
			[[ ${report} ]] && OUTPUT+=" ${report}"
			report=$(cmp-get_makereport "+%d" ${va} 32 "")
			report=$(cmp-get_makereport "~%d" ${vc} 33 "${report}")
			report=$(cmp-get_makereport "-%d" ${vr} 31 "${report}")
			report=$(cmp-get_makereport "vars" -1 94 "${report}")
			[[ ${report} ]] && OUTPUT+=" ${report}"
			if (( errno & 8 )); then
				if ${OPT[color]}; then
					OUTPUT+=$(printf " \e[31m%s\e[0m" "[BREAKING]")
				else
					OUTPUT+=" [BREAKING]"
				fi
			fi
			OUTPUT+=$'\n'
		fi

		${OPT[full-abidiff]} && OUTPUT+="${output}"$'\n'
	done

	report=$(cmp-get_makereport "+%d" ${add} 32 "")
	report=$(cmp-get_makereport "~%d" ${chg} 33 "${report}")
	report=$(cmp-get_makereport "-%d" ${del} 31 "${report}")
	(( brk )) && report=$(cmp-get_makereport ">B<" 1 31 "${report}")
	report=$(cmp-get_makereport "ABI" -1 90 "${report}")
	[[ ${report} ]] && REPORT+=" ${report}"
}

# cmp-output_abi_diff_issue <shortmsg> <showissue>
#	Add to REPORT for a cmp-output_abi_diff issue using <shortmsg>
#	If showissue is 0, will only show with --confirm, or always if 1
cmp-output_abi_diff_issue() {
	local report
	report=$(cmp-get_makereport "${1}" ${2} 31 "")
	report=$(cmp-get_makereport "ABI" -1 90 "${report}")
	[[ ${report} ]] && REPORT+=" ${report}"
}

# cmp-output_filelist <compare1>
#	Add to OUTPUT filelist for 1 value from cmp-get_tocompare
#	Simplified version of cmp-output_filelist_diff
cmp-output_filelist() {
	${OPT[single-filelist]} || return

	local line
	for line in "${LIST_NEW[@]:3}"; do
		if ${OPT[color]}; then
			OUTPUT+=$(printf " \e[90mFILES: \e[32m%s\e[0m" "${line}")$'\n'
		else
			OUTPUT+=" FILES: ${line}"$'\n'
		fi
	done
}

# cmp-output_filelist_diff
#	Add to OUTPUT differences between LIST_OLD and LIST_NEW while optionally
#	omitting changes to version in filenames (replaced by <snip>)
cmp-output_filelist_diff() {
	local -a old=() new=()

	if ${OPT[ver-keep]}; then
		old=("${LIST_OLD[@]:3}")
		new=("${LIST_NEW[@]:3}")
	else
		# To focus on showing interesting filelist changes rather than "dir
		# name changed version and all files under it show in the diff", strip
		# version and replace by placeholder. Unknown which version these use
		# so try ${PVR}->${PV}->${PV%%_*} for the most common.
		local file path
		for file in "${LIST_OLD[@]:3}"; do
			${OPT[ver-dironly]} && [[ ${file} =~ / ]] && path=${file%/*} || path=${file}
			path=${path//${LIST_OLD[0]}/<snip>}
			path=${path//${LIST_OLD[0]%-r[0-9]*}/<snip>}
			path=${path//${LIST_OLD[0]%%_*}/<snip>}
			${OPT[ver-dironly]} && [[ ${file} =~ / ]] && path+=/${file##*/}
			old+=("${path}")
		done
		for file in "${LIST_NEW[@]:3}"; do
			${OPT[ver-dironly]} && [[ ${file} =~ / ]] && path=${file%/*} || path=${file}
			path=${path//${LIST_NEW[0]}/<snip>}
			path=${path//${LIST_NEW[0]%-r[0-9]*}/<snip>}
			path=${path//${LIST_NEW[0]%%_*}/<snip>}
			${OPT[ver-dironly]} && [[ ${file} =~ / ]] && path+=/${file##*/}
			new+=("${path}")
		done
	fi

	local report
	if ! (( ${#old[@]} || ${#new[@]} )); then
		# this is rather unlikely
		report=$(cmp-get_makereport "N/A" 0 31 "")
		report=$(cmp-get_makereport "FILES" -1 90 "${report}")
		[[ ${report} ]] && REPORT+=" ${report}"
		return
	fi

	local output=$(
		diff -U0 \
			<(printf "%s" "${old[@]/%/$'\n'}") \
			<(printf "%s" "${new[@]/%/$'\n'}") \
			| grep -v '@@\|---\|+++'
		[[ ${PIPESTATUS[*]} == [01]\ [01] ]] || die "failed comparing lists"
	)

	local IFS=$'\n' color line
	local -i add=0 del=0
	for line in ${output}; do
		case ${line:0:1} in
			+) color=32; add+=1;;
			-) color=31; del+=1;;
			*) color=90;; # unused unless increase -U*
		esac

		if ${OPT[filelist-diff]}; then
			if ${OPT[color]}; then
				OUTPUT+=$(printf " \e[90mFILES:\e[${color}m%s\e[0m" "${line}")$'\n'
			else
				OUTPUT+=" FILES:${line}"$'\n'
			fi
		fi
	done

	report=$(cmp-get_makereport "+%d" ${add} 32 "")
	report=$(cmp-get_makereport "-%d" ${del} 31 "${report}")
	report=$(cmp-get_makereport "FILES" -1 90 "${report}")
	[[ ${report} ]] && REPORT+=" ${report}"
}

# cmp-output_size <compare1>
#	Add to OUTPUT size and filecount for 1 value from cmp-get_tocompare
#	Simplified version of cmp-output_size_diff
cmp-output_size() {
	${OPT[single-size]} || return

	local c1= c2= cn=
	if ${OPT[color]}; then
		c1=$'\e[90m'
		c2=$'\e[33m'
		cn=$'\e[0m'
	fi
	OUTPUT+=$(printf "  ${c1}SIZE: ${c2}%.2fMiB${c1}, ${c2}%d${c1} files${cn}\n" \
		$((10**2 * ${LIST_NEW[2]} / 1024**2))e-2 $((${#LIST_NEW[@]} - 3)))
}

# cmp-output_size_diff
#	Add to OUTPUT difference in size
cmp-output_size_diff() {
	local sper
	local -i sold=${LIST_OLD[2]}
	local -i snew=${LIST_NEW[2]}

	if (( sold && snew )); then
		sper=$((10**4 * snew / sold - 10**4))
	elif (( snew )); then
		sper=10000 # pretend 0->1 is 100%
	elif (( sold )); then
		sper=-10000
	else
		sper=0
	fi

	if ${OPT[size-diff]} && (( ${sper#-} >= OPT[size-thres] )); then
		local c1= c2= cn=
		if ${OPT[color]}; then
			c1=$'\e[90m'
			c2=$'\e[33m'
			cn=$'\e[0m'
		fi
		OUTPUT+=$(
			printf "  ${c1}SIZE: ${c2}%.2fMiB${c1} -> ${c2}%.2fMiB${c1}, ${c2}%d${c1} -> ${c2}%d files${cn}\n" \
				$((10**2 * sold / 1024**2))e-2 \
				$((10**2 * snew / 1024**2))e-2 \
				$((${#LIST_OLD[@]} - 3)) \
				$((${#LIST_NEW[@]} - 3)))$'\n'
	fi

	if ${OPT[confirm]} || (( ${sper#-} >= OPT[size-thres] )); then
		printf -v sper "%.2f" ${sper}e-2
		if (( snew >= sold )); then
			report=$(cmp-get_makereport "+${sper}%%" 1 32 "")
		else
			report=$(cmp-get_makereport "${sper}%%" 1 31 "")
		fi
		report=$(cmp-get_makereport "SIZE" -1 90 "${report}")
		[[ ${report} ]] && REPORT+=" ${report}"
	fi
}

# cmp-output_soname <compare>
#	Add to OUTPUT soname list for 1 value from cmp-get_tocompare
#	Simplified version of cmp-output_soname_diff
cmp-output_soname() {
	${OPT[single-soname]} || return

	local IFS=$'\n'
	local -a new=("${LIST_NEW[@]:3}") tmp
	new=($(cmp-get_shared "${new[@]/#/${LIST_NEW[1]}}"))
	if (( ${#new[@]} )); then
		tmp=($(cmp-get_scanelf -M32 -F'%S(32)#F' -- "${new[@]}"))
		tmp+=($(cmp-get_scanelf -M64 -F'%S(64)#F' -- "${new[@]}"))
		(( ${#tmp[@]} )) || tmp=($(cmp-get_scanelf -F'%S#F' -- "${new[@]}"))
		new=("${tmp[@]}")
	fi
	unset IFS

	local line
	for line in "${new[@]}"; do
		if ${OPT[color]}; then
			OUTPUT+=$(printf "\e[90mSONAME: \e[36m%s\e[0m" "${line}")$'\n'
		else
			OUTPUT+="SONAME: ${line}"$'\n'
		fi
	done
}

# cmp-output_soname_diff
#	Add to OUTPUT differences between LIST_OLD and LIST_NEW but only
#	for SONAME changes
cmp-output_soname_diff() {
	local IFS=$'\n'
	local -a new=("${LIST_NEW[@]:3}") old=("${LIST_OLD[@]:3}") tmp
	new=($(cmp-get_shared "${new[@]/#/${LIST_NEW[1]}}"))
	old=($(cmp-get_shared "${old[@]/#/${LIST_OLD[1]}}"))

	# replace lists with scanelf output, do three runs to differenciate
	# 32bit/64bit without guessing what the libdir may be, and one more
	# if got nothing (to handle potential exotic arches)
	# TODO?: lacks further awareness of different versions with same soname
	if (( ${#old[@]} )); then
		tmp=($(cmp-get_scanelf -M32 -F'%S(32)' -- "${old[@]}"))
		tmp+=($(cmp-get_scanelf -M64 -F'%S(64)' -- "${old[@]}"))
		(( ${#tmp[@]} )) || tmp=($(cmp-get_scanelf -F'%S' -- "${old[@]}"))
		old=("${tmp[@]}")
	fi
	if (( ${#new[@]} )); then
		tmp=($(cmp-get_scanelf -M32 -F'%S(32)' -- "${new[@]}"))
		tmp+=($(cmp-get_scanelf -M64 -F'%S(64)' -- "${new[@]}"))
		(( ${#tmp[@]} )) || tmp=($(cmp-get_scanelf -F'%S' -- "${new[@]}"))
		new=("${tmp[@]}")
	fi

	unset IFS

	# need uniq on field1, and 2+ can have spaces (`rev | uniq -f1` unsafe),
	# do manually (also save to SCANELF_* to be re-used by cmp-output_abi_diff)
	local elem
	local -A uniq=()
	for elem in "${old[@]}"; do
		if [[ ! ${uniq[${elem%% *}]:-} ]]; then
			uniq[${elem%% *}]=:
			SONAME_OLD+=("${elem}")
		fi
	done
	uniq=()
	for elem in "${new[@]}"; do
		if [[ ! ${uniq[${elem%% *}]:-} ]]; then
			uniq[${elem%% *}]=:
			SONAME_NEW+=("${elem}")
		fi
	done

	local output report
	if [[ ${#SONAME_OLD[@]} == 0 && ${#SONAME_NEW[@]} == 0 ]]; then
		report=$(cmp-get_makereport "N/A" 0 31 "")
		report=$(cmp-get_makereport "SONAME" -1 90 "${report}")
		[[ ${report} ]] && REPORT+=" ${report}"
		return # nothing to compare
	fi

	old=("${SONAME_OLD[@]%% *}")
	new=("${SONAME_NEW[@]%% *}")
	output=$(
		diff -U0 \
			<(printf "%s" "${old[@]/%/$'\n'}") \
			<(printf "%s" "${new[@]/%/$'\n'}") \
			| grep -v '@@\|---\|+++'
		[[ ${PIPESTATUS[*]} == [01]\ [01] ]] || die "failed comparing lists"
	)

	local color line IFS=$'\n'
	local -i add=0 del=0
	for line in ${output}; do
		case ${line:0:1} in
			+) color=36; add+=1;;
			-) color=33; del+=1;;
			*) color=90;; # unused unless increase -U*
		esac

		if ${OPT[soname-diff]}; then
			if ${OPT[color]}; then
				OUTPUT+=$(printf "\e[90mSONAME:\e[${color}m%s\e[0m" "${line}")$'\n'
			else
				OUTPUT+="SONAME:${line}"$'\n'
			fi
		fi
	done

	report=$(cmp-get_makereport "+%d" ${add} 36 "")
	report=$(cmp-get_makereport "-%d" ${del} 33 "${report}")
	report=$(cmp-get_makereport "SONAME" -1 90 "${report}")
	[[ ${report} ]] && REPORT+=" ${report}"
}

# cmp-print_header <compare1> <compare2>
#	Print what is being compared using values from cmp-get_tocompare
cmp-print_header() {
	local old=$(cmp-get_compare2readable "${1}")
	local new=$(cmp-get_compare2readable "${2}")
	msg "QA: comparing ${old} with ${new}"
}

# cmp-print_header_single <compare>
#	Print single image being checked using values from cmp-get_tocompare
cmp-print_header_single() {
	msg "QA: listing $(cmp-get_compare2readable "${1}") info"
}

# normalize arguments to something we can use
IFS=$'\n'
set -- $(cmp-get_tocompare "$@")
unset IFS

# init globals used by cmp-output_*
OUTPUT=
REPORT=
if (( ${#} == 2 )); then
	declare -a LIST_OLD=($(cmp-get_filelist "${1}"))
	declare -a LIST_NEW=($(cmp-get_filelist "${2}"))
	${OPT[single-auto]} && OPT[single]=false
else
	declare -a LIST_NEW=($(cmp-get_filelist "${1}"))
fi
declare -a SONAME_OLD=()
declare -a SONAME_NEW=()

if ${OPT[single]}; then
	cmp-output_filelist
	cmp-output_soname
	cmp-output_size

	if [[ ${OUTPUT} ]]; then
		cmp-print_header_single "${2:-${1}}"
		msg "${OUTPUT%$'\n'}"
		OUTPUT=
	fi
fi

if (( ${#} == 2 )) && ${OPT[compare]}; then
	cmp-output_filelist_diff
	cmp-output_soname_diff
	cmp-output_abi_diff
	cmp-output_size_diff

	if [[ ${OUTPUT} ]]; then
		cmp-print_header "$@"
		msg "${OUTPUT%$'\n'}"
		${OPT[report]} && msg "------>${REPORT}"
	elif [[ ${REPORT} ]] && ${OPT[report]}; then
		cmp-print_header "$@"
		msg "------>${REPORT}"
	fi
fi

:

# vim: ts=4
