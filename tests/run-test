#!/usr/bin/env bash
set -euo pipefail
die() { echo "TestError: ${*} (${FUNCNAME[1]}:${BASH_LINENO[0]})" >&2; exit 1; }
skip() { echo "TestSkip: ${*}" >&2; exit 77; }

# arguments coming from meson
[[ ${#} == 2 && -f ${1} && -f ${2} ]] \
	|| die "invalid usage, attempted to use directly?"
TEST=${1}
SCRIPT=${2}

PACKAGE='@package@'
VERSION='@version@'
DATAROOT='@dataroot@'
WORKROOT='@workroot@'

LIBD100='@libdummy100@' # initial
LIBD101='@libdummy101@' # no abi changes
LIBD102='@libdummy102@' # broken abi
LIBD200='@libdummy200@' # soname change
LIBA300='@libalt300@' # initial
LIBA400='@libalt400@' # soname change
EXED='@exedummy@' # libdummy symbols
EXEA='@exealt@' # libdummy+libalt symbols

DATADIR=${DATAROOT}/${SCRIPT##*/}/data
WORKDIR=${WORKROOT}/${SCRIPT##*/}/${TEST##*/}

# check_abidiff
#	Calls skip() if abidiff is not usable
check_abidiff() {
	type abidiff >/dev/null || skip "abidiff not found in PATH"

	local file
	file=$(file "${LIBD100}") # check on its own for -e exit status

	[[ ${file} == *debug_info* ]] || skip "debug symbols needed for abidiff tests, build with -g"
}

# copydat <files...>
#	Copy data files to ${WORKDIR}
copydat() {
	cp "${@/#/${DATADIR}/}" .
}

# expect [options] <expected-glob> [args]
#	Return true if ${SCRIPT}'s output matches <expected-glob>
#	Options:
#		-! invert match
#		-e use regex instead of glob
#		-2 compare with stderr instead of stdout
expect() {
	local op='==' invert= stdout=true

	while (( ${#} )); do
		case ${1} in
			-!) invert='!';;
			-2) stdout=false;;
			-e) op='=~';;
			*) break;;
		esac
		shift
	done

	local output errno=0
	if ${stdout}; then
		output=$("${BASH}" "${SCRIPT}" "${@:2}") || errno=${?}
		echo "${output}"
	else
		{ output=$("${BASH}" "${SCRIPT}" "${@:2}" 3>&2 2>&1 1>&3-) || errno=${?}; } 2>&1
		echo "${output}" >&2
	fi

	eval "[[ ${invert} \${output} ${op} ${1// /\\ } ]]" || die "output mismatch for '${*}'"

	return ${errno}
}

# get_ebuild <PN> <PVR> <bin:file,ARG:value,inherit:file,...>
# 	Echos path to ebuild created as <PN>-<PVR>.ebuild (category = dev-test/)
#	Lowercase prefix determines do* command to use, e.g. bin: = dobin <file>
#	Uppercase prefix means to set a variable like "RDEPEND:value"
#	inherit prefix will inherit an eclass from ${DATADIR}
#	: on its own means to install nothing
#	Note: these ebuilds should not actually build anything, use meson
get_ebuild() {
	[[ -d ${ROOT} ]]

	local pn=${1} pvr=${2}
	shift 2

	local key val soname= files= vars= inherit=
	while (( ${#} )); do
		key=${1%%:*}
		val=${1#*:}
		if [[ ! ${key} ]]; then
			files+=':;'
		elif [[ ${key} == inherit ]]; then
			if [[ -f ${DATADIR}/${val}.eclass ]]; then
				cp ${DATADIR}/${val}.eclass root/eclass/
			fi
			inherit+=" ${val}"
		elif [[ ${key,,} == ${key} ]]; then
			files+="do${key} "
			if [[ ${val:0:1} != / ]]; then
				files+="${PWD}/"
			fi
			files+="${val};"

			if [[ ${key} == lib.so ]]; then
				val=${val##*/}
				soname=${val##*.so.}
				soname=${val%%.so.*}.so.${soname%%.*}
				files+="dosym -r /usr/\$(get_libdir)/{${val},${soname}};"
				files+="dosym -r /usr/\$(get_libdir)/{${val},${val%%.so.*}.so};"
			fi
		else
			vars+="${key}=\"${val}\";"
		fi
		shift
	done

	if [[ ! ${files} ]]; then
		# always install at least something
		files="newbin - ${pn}-${pvr} <<<'#!/usr/bin/env true';"
	elif [[ ${soname} ]]; then
		files+="newenvd - 00\${PN} <<<LDPATH=\"\\\"${ROOT}/usr/\$(get_libdir)\\\"\";"
	fi

	mkdir -p "${ROOT}"/overlay/dev-test/${pn}

	local ebuild=${ROOT}/overlay/dev-test/${pn}/${pn}-${pvr}.ebuild
	cat > "${ebuild}" <<-EOF
		EAPI=8

		${inherit:+inherit${inherit}}

		DESCRIPTION="ebuild for ${pn}"
		HOMEPAGE="https://localhost/"
		S="\${WORKDIR}"

		LICENSE="BSD-2"
		SLOT="0"
		KEYWORDS="test"

		${vars}

		src_install() {
			${files}
		}
	EOF

	echo "${ebuild}"
}

# md5cmp <md5sum> <file>
#	Return true if <file> matches <md5sum>
md5cmp() {
	md5sum --quiet -c - <<<"${*}" >/dev/null || die "checksum mismatch for '${2}'"
}

# set_portroot
#	Setup and export ROOT, EROOT, and PORTAGE_CONFIGROOT
#	Needed for any operation with portageq/qlist/ebuild/etc...
ROOT=
set_portroot() {
	# skip if these commands are missing rather than fail (not on Gentoo?)
	type ebuild portageq qatom qlist >/dev/null \
		|| skip "portage or portage-utils missing"

	export ROOT="${PWD}/root"
	export EROOT="${ROOT}"
	export PORTAGE_CONFIGROOT="${ROOT}"

	mkdir -p root/{etc/portage,overlay/{eclass,metadata,profiles},tmp}

	cat > root/etc/portage/repos.conf <<-EOF
		[DEFAULT]
		main-repo = ${PACKAGE}

		[${PACKAGE}]
		location = ${ROOT}/overlay
	EOF

	cat > root/etc/portage/make.conf <<-EOF
		ACCEPT_KEYWORDS="test"
		FEATURES="-* unprivileged"
		PORTAGE_TMPDIR="${ROOT}/tmp"
	EOF

	cat > root/overlay/metadata/layout.conf <<-EOF
		masters =
		thin-manifests = true
	EOF

	cat > root/overlay/profiles/make.defaults <<-EOF
		ARCH="test"
		CHOST="test"
	EOF
	echo test > root/overlay/profiles/arch.list
	echo dev-test > root/overlay/profiles/categories
	echo ${PACKAGE} > root/overlay/profiles/repo_name

	ln -s ../../overlay/profiles root/etc/portage/make.profile
}

# xfail <expected-errno>
#	Abort if last return value is not <expected-errno>
xfail() {
	local errno=${?}

	[[ ${errno} == ${1} ]] \
		|| die "expected return value ${1}, got ${errno}"
}

# setup per-test work dir in build dir, cleanup previous if exists
if [[ -f ${WORKDIR}/test-tmp-dir ]]; then
	rm -r "${WORKDIR}"
fi
mkdir "${WORKDIR}"
touch "${WORKDIR}"/test-tmp-dir # sanity file for safer `rm -r`

# try to clear portage env vars not to confuse ebuild-run-in-ebuild,
# and also clear env known to be used by scripts here
# (tempting to use env -i but users may need obscure env vars)
unset FEATURES {,E,B,SYS,ESYS}ROOT USE
unset "${!PORTAGE@}" "${!PORTDIR@}" "${!EBUILD@}" "${!ACCEPT@}"
unset "${!EOLDNEW@}"
export LC_ALL=C EPREFIX=

# run test in work dir
cd "${WORKDIR}"
. "${TEST}"

# vim: ts=4
