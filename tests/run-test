#!/usr/bin/env bash
set -euo pipefail
die() { echo "TestError: ${*} (${FUNCNAME[1]})" >&2; exit 1; }
skip() { echo "TestSkip: ${*}" >&2; exit 77; }

[[ ${#} == 3 && ${1} && -f ${2} ]] || die "${0##*/} should not be used directly"

if [[ -d data ]]; then
	DAT=${PWD}/data
else
	DAT=
fi

# copydat <files...>
#	Copy data files to current temporary dir
copydat() {
	[[ ${DAT} ]]
	cp "${@/#/${DAT}/}" .
}

# expect [options] <expected-glob> <source> [args]
#	Return true if source's output matches <expected-glob>
#	Options:
#		-2 compare with stderr instead of stdout
expect() {
	local stdout=true

	while (( ${#} )); do
		case ${1} in
			-2) stdout=false;;
			*) break;;
		esac
		shift
	done

	local output errno=0
	if ${stdout}; then
		output=$(. "${@:2}") || errno=${?}
		echo "${output}"
	else
		{ output=$(. "${@:2}" 3>&2 2>&1 1>&3-) || errno=${?}; } 2>&1
		echo "${output}" >&2
	fi

	(( ! errno )) || return ${errno}

	eval "[[ \${output} == ${1// /\\ } ]]" || die "output did not match '${1}'"
}

# md5cmp <md5sum> <file>
#	Return true if <file> matches <md5sum>
md5cmp() {
	md5sum --quiet -c - <<<"${*}" >/dev/null || die "checksum mismatch for '${2}'"
}

# setup per-test temporary dir in build dir, cleanup previous if exists
if [[ -f ${1}/test-tmp-dir ]]; then
	rm -r "${1}"
fi
mkdir "${1}"
touch "${1}"/test-tmp-dir # sanity file for safer `rm -r`

# run test in temporary dir
cd "${1}"
. "${@:2}"

# vim: ts=4
